return(c())
}
#Iteratively search behind a specific sleep index to locate any additional sleep (part 2 of SLNW version B)
search_backwards <- function(sleep_index, curr_noon, noon_days, data){
curr_position <- sleep_index - 1
while(curr_position >= 1 && (as.numeric(difftime(data[sleep_index, 1], data[curr_position, 1]), units = "secs") - data[curr_position, 3]) <= 900){
curr_position <- curr_position - 1
}
backward_SLNW <- c((curr_position + 1):(sleep_index - 1))
small_sleep = FALSE
for(i in length(backward_SLNW)){
if(data[backward_SLNW[i], 3] >= 7200 && data[backward_SLNW[i], 4] < 2){
return(backward_SLNW)
}else if(data[backward_SLNW[i], 3] >= 1800 && data[backward_SLNW[i], 4] < 2){
small_sleep = TRUE
}
}
total_steps <- data[sleep_index, 5] - data[backward_SLNW[1], 5]
if((small_sleep && total_steps <= 20) || total_steps == 0){
return(backward_SLNW)
}
return(c())
}
#Now we can iterate through each day and identify our sleep periods--this is version B of the SLNW alg parts 1-2
all_SLNW <- c()
for(i in 1:(length(noon_days) - 1)){
sleep_indices = c()
longest_bout = 0
for(j in noon_days[i]:(noon_days[i + 1] - 1)){
if(data[j, 3] >= 18000 && data[j, 4] < 2){
sleep_indices <- c(sleep_indices, j)
} else if(data[j, 3] >= 7200 && data[j, 4] < 2){
longest_bout = j
}
}
if(length(sleep_indices) == 0){
sleep_indices <- c(sleep_indices, longest_bout)
}
for(j in 1:length(sleep_indices)){
all_SLNW <- c(all_SLNW, search_backwards(sleep_indices[j], i, noon_days, data), sleep_indices[j], search_forwards(sleep_indices[j], i, noon_days, data))
}
}
all_SLNW <- all_SLNW[!duplicated(all_SLNW)]
#Lastly we move these sleep bouts to a new dataframe
sleep_data <- data.frame(data[all_SLNW,])
data <- data[-c(all_SLNW),]
#REMOVE INVALID DAYS----
#Having removed all of our SLNW data, we now need to go through and remove all invalid days (part 3 of Version B)
#First up we need to quickly map the end of our days
day_end <- c()
counter <- 1
for(i in 1:nrow(data)){
if(substr(data[i, 1], 1, 10) != valid_days[counter]){
day_end <- c(day_end, i-1)
counter <- counter + 1
}
}
day_end <- c(day_end, nrow(data))
#next we use this end day mapping to iterate through each day and evaluate it to see if it fits the criteria for a valid day
invalid_days <- c()
for(i in 1:length(day_end)){
check_time <- 0
check_largest <- 0
if(i == 1){
start = 1
prev_steps = 0
}else{
start = day_end[i-1] + 1
prev_steps = data[start-1, 5]
}
for(j in start:day_end[i]){
check_time <- check_time + data[j, 3]
if(data[j, 3] > check_largest){
check_largest <- data[j, 3]
}
}
if(check_time < 36000 || check_largest >= 0.95 * check_time || (data[day_end[i], 5] - prev_steps) < 500){
print(data[day_end[i], 5] - prev_steps)
invalid_days <- c(invalid_days, valid_days[i])
}
}
#Lastly we iterate back through the events one more time to take note of the index of every event on an invalid day
to_remove <- c()
for(i in 1:nrow(data)){
if(substr(data[i, 1], 1, 10) %in% invalid_days){
to_remove <- c(to_remove, i)
}
}
invalid_data <- data.frame(data[to_remove,])
data <- data[-c(to_remove),]
#real quick we'll once again clear up our working env
rm(all_SLNW, check_largest, check_time, counter, curr_day, day_counter, day_end, i, j, longest_bout, noon_days, prev_steps, sleep_indices, start, to_remove)
#SUMMARY STATISTICS----
#Lastly we'll pull out the valid days and build another day_end mapping
new_valid_days <- c()
for(i in 1:length(valid_days)){
if(!(valid_days[i] %in% invalid_days)){
new_valid_days <- c(new_valid_days, valid_days[i])
}
}
#building our mapping as before...
day_end <- c(0)
counter <- 1
for(i in 1:nrow(data)){
if(substr(data[i, 1], 1, 10) != new_valid_days[counter]){
day_end <- c(day_end, i-1)
counter <- counter + 1
}
}
day_end <- c(day_end, nrow(data))
#Now we just calculate whatever summary statistics we want
all_sit <- c()
all_stand <- c()
all_move <- c()
for(i in 1:length(new_valid_days)){
sit <- c()
stand <- c()
move <- c()
for(j in (day_end[i]+1):day_end[i+1]){
if(data[j, 4] == 0){
sit <- c(sit, data[j, 3])
}else if(data[j, 4] ==1){
stand <- c(stand, data[j, 3])
}else{
move <- c(move, data[j, 3])
}
}
all_sit <- c(all_sit, sit)
all_stand <- c(all_stand, stand)
all_move <- c(all_move, move)
print(paste("SUMMARY STATISTICS FOR: ", new_valid_days[i]))
print(paste("    TOTAL NUMBER OF SITTING/LYING BOUTS: ", toString(length(sit))))
print(paste("    LARGEST SITTING/LYING BOUT: ", toString(max(unlist(sit)))))
print(paste("    SMALLEST SITTING/LYING BOUT: ", toString(min(unlist(sit)))))
print(paste("    AVERAGE SITTING/LYING BOUT: ", toString(mean(sit))))
print("")
print(paste("    TOTAL NUMBER OF STANDING BOUTS: ", toString(length(stand))))
print(paste("    LARGEST STANDING BOUT: ", toString(max(unlist(stand)))))
print(paste("    SMALLEST STANDING BOUT: ", toString(min(unlist(stand)))))
print(paste("    AVERAGE STANDING BOUT: ", toString(mean(stand))))
print("")
print(paste("    TOTAL NUMBER OF MOVING BOUTS: ", toString(length(move))))
print(paste("    LARGEST MOVING BOUT: ", toString(max(unlist(move)))))
print(paste("    SMALLEST MOVING BOUT: ", toString(min(unlist(move)))))
print(paste("    AVERAGE MOVING BOUT: ", toString(mean(move))))
print("")
print("")
}
for(i in 1){
print("SUMMARY STATISTICS FOR ENTIRE DATASET")
print(paste("    TOTAL NUMBER OF SITTING/LYING BOUTS: ", toString(length(all_sit))))
print(paste("    LARGEST SITTING/LYING BOUT: ", toString(max(unlist(all_sit)))))
print(paste("    SMALLEST SITTING/LYING BOUT: ", toString(min(unlist(all_sit)))))
print(paste("    AVERAGE SITTING/LYING BOUT: ", toString(mean(all_sit))))
print("")
print(paste("    TOTAL NUMBER OF STANDING BOUTS: ", toString(length(all_stand))))
print(paste("    LARGEST STANDING BOUT: ", toString(max(unlist(all_stand)))))
print(paste("    SMALLEST STANDING BOUT: ", toString(min(unlist(all_stand)))))
print(paste("    AVERAGE STANDING BOUT: ", toString(mean(stand))))
print("")
print(paste("    TOTAL NUMBER OF MOVING BOUTS: ", toString(length(all_move))))
print(paste("    LARGEST MOVING BOUT: ", toString(max(unlist(all_move)))))
print(paste("    SMALLEST MOVING BOUT: ", toString(min(unlist(all_move)))))
print(paste("    AVERAGE MOVING BOUT: ", toString(mean(all_move))))
print("")
print("")
}
write.csv(data, "valid_data.csv")
write.csv(invalid_data, "invalid_data.csv")
write.csv(sleep_data, "sleep_data.csv")
View(sleep_data)
View(sleep_data)
View(sleep_data)
View(sleep_data)
activpalProcessing::process.AP(data_path)
#set variable "wd" equal to a string containing the full path to the directory you intend to work from
wd <- "C:/Users/User/Desktop/PNC_Lab/activPAL-bout-detection"
setwd(wd)
#set variable "data_path" equal to a string containing the partial path FROM YOUR WORKING DIRECTORY
data_path <- "sample_data/SA009-SA009-AP840032 11Apr19 12-00am for 12d 16h 22m-VANE-PB08090417-Events.csv"
#now we're ready to go ahead and run our activPAL bout detection data reduction on our dataset
data <- activpalProcessing::activpal.file.reader(data_path)
#first we count how many steps occur on each day
days <- 0
steps <- data.frame(days)
for(i in 1:nrow(data)){
date <- substr(data[i, 1], 1, 10)
if(!(date %in% colnames(steps))){
steps[, date] <- data[i, 5]
steps[1, "days"] <- steps[1, "days"] + 1
} else {
steps[1, date] <- data[i, 5]
}
}
steps$days <- NULL
#next we remove down to the 7 days with the largest step counts and save those days into a list"valid_days"
while(ncol(steps) > 7){
least_steps <- min(steps, na.rm = TRUE)
for(i in 1:ncol(data)){
if(least_steps == steps[1, i]){
steps[i] <- NULL
break
}
}
}
valid_days = colnames(steps)
#lastly just as a nicety we'll clean up our working env
rm(steps, date, days, i, least_steps)
#now that we have a list of valid days, we can cut out all data which took place outside of the experiment
days_to_remove <- c()
for(i in 1:nrow(data)){
if(!(substr(data[i, 1], 1, 10) %in% valid_days)){
days_to_remove <- c(days_to_remove, i)
}
}
data <- data[-c(days_to_remove),]
#as before let's clean up our working env for clarity
rm(i, days_to_remove)
#REMOVE SLNW BOUTS----
#First we need to partition out our data into noon-noon days so we can effectively search for sleep
curr_day <- paste(valid_days[1], "12:00:00", sep = " ")
day_counter <- 1
noon_days <- c(1)
for(i in 1:nrow(data)){
if(as.numeric(difftime(data[i, 1], curr_day), units = "secs") > 0) {
noon_days <- c(noon_days, i)
day_counter <- day_counter + 1
if(day_counter > length(valid_days)){
break
} else {
curr_day <- paste(valid_days[day_counter], "12:00:00", sep = " ")
}
}
}
#To account for the case that our day 7 data never crossed the noon threshold we add a fake index at one past the array
if(day_counter == length(valid_days)){
noon_days <- c(noon_days, nrow(data) + 1)
}
#Here we'll define two helper functions for later--namely to search forwards and backwards for potential SLNW bouts
#Iteratively search ahead of a specific sleep index to locate any addition sleep (part 2 of SLNW version B)
search_forwards <- function(sleep_index, curr_noon, noon_days, data){
curr_position <- sleep_index + 1
while(curr_position <= nrow(data) && (as.numeric(difftime(data[curr_position, 1], data[sleep_index, 1]), units = "secs") - data[sleep_index, 3]) <= 900){
curr_position <- curr_position + 1
}
forward_SLNW <- c((sleep_index + 1):(curr_position - 1))
small_sleep = FALSE
for(i in length(forward_SLNW)){
if(data[forward_SLNW[i], 3] >= 7200 && data[forward_SLNW[i], 4] < 2){
return(forward_SLNW)
}else if(data[forward_SLNW[i], 3] >= 1800 && data[forward_SLNW[i], 4] < 2){
small_sleep = TRUE
}
}
total_steps <- data[forward_SLNW[length(forward_SLNW)], 5] - data[sleep_index, 5]
if((small_sleep && total_steps <= 20) || total_steps == 0){
return(forward_SLNW)
}
return(c())
}
#Iteratively search behind a specific sleep index to locate any additional sleep (part 2 of SLNW version B)
search_backwards <- function(sleep_index, curr_noon, noon_days, data){
curr_position <- sleep_index - 1
while(curr_position >= 1 && (as.numeric(difftime(data[sleep_index, 1], data[curr_position, 1]), units = "secs") - data[curr_position, 3]) <= 900){
curr_position <- curr_position - 1
}
backward_SLNW <- c((curr_position + 1):(sleep_index - 1))
small_sleep = FALSE
for(i in length(backward_SLNW)){
if(data[backward_SLNW[i], 3] >= 7200 && data[backward_SLNW[i], 4] < 2){
return(backward_SLNW)
}else if(data[backward_SLNW[i], 3] >= 1800 && data[backward_SLNW[i], 4] < 2){
small_sleep = TRUE
}
}
total_steps <- data[sleep_index, 5] - data[backward_SLNW[1], 5]
if((small_sleep && total_steps <= 20) || total_steps == 0){
return(backward_SLNW)
}
return(c())
}
#Now we can iterate through each day and identify our sleep periods--this is version B of the SLNW alg parts 1-2
all_SLNW <- c()
for(i in 1:(length(noon_days) - 1)){
sleep_indices = c()
longest_bout = 0
for(j in noon_days[i]:(noon_days[i + 1] - 1)){
if(data[j, 3] >= 18000 && data[j, 4] < 2){
sleep_indices <- c(sleep_indices, j)
} else if(data[j, 3] >= 7200 && data[j, 4] < 2){
longest_bout = j
}
}
if(length(sleep_indices) == 0){
sleep_indices <- c(sleep_indices, longest_bout)
}
for(j in 1:length(sleep_indices)){
all_SLNW <- c(all_SLNW, search_backwards(sleep_indices[j], i, noon_days, data), sleep_indices[j], search_forwards(sleep_indices[j], i, noon_days, data))
}
}
all_SLNW <- all_SLNW[!duplicated(all_SLNW)]
#Lastly we move these sleep bouts to a new dataframe
sleep_data <- data.frame(data[all_SLNW,])
data <- data[-c(all_SLNW),]
#REMOVE INVALID DAYS----
#Having removed all of our SLNW data, we now need to go through and remove all invalid days (part 3 of Version B)
#First up we need to quickly map the end of our days
day_end <- c()
counter <- 1
for(i in 1:nrow(data)){
if(substr(data[i, 1], 1, 10) != valid_days[counter]){
day_end <- c(day_end, i-1)
counter <- counter + 1
}
}
day_end <- c(day_end, nrow(data))
#next we use this end day mapping to iterate through each day and evaluate it to see if it fits the criteria for a valid day
invalid_days <- c()
for(i in 1:length(day_end)){
check_time <- 0
check_largest <- 0
if(i == 1){
start = 1
prev_steps = 0
}else{
start = day_end[i-1] + 1
prev_steps = data[start-1, 5]
}
for(j in start:day_end[i]){
check_time <- check_time + data[j, 3]
if(data[j, 3] > check_largest){
check_largest <- data[j, 3]
}
}
if(check_time < 36000 || check_largest >= 0.95 * check_time || (data[day_end[i], 5] - prev_steps) < 500){
print(data[day_end[i], 5] - prev_steps)
invalid_days <- c(invalid_days, valid_days[i])
}
}
#Lastly we iterate back through the events one more time to take note of the index of every event on an invalid day
to_remove <- c()
for(i in 1:nrow(data)){
if(substr(data[i, 1], 1, 10) %in% invalid_days){
to_remove <- c(to_remove, i)
}
}
invalid_data <- data.frame(data[to_remove,])
data <- data[-c(to_remove),]
#real quick we'll once again clear up our working env
rm(all_SLNW, check_largest, check_time, counter, curr_day, day_counter, day_end, i, j, longest_bout, noon_days, prev_steps, sleep_indices, start, to_remove)
#SUMMARY STATISTICS----
#Lastly we'll pull out the valid days and build another day_end mapping
new_valid_days <- c()
for(i in 1:length(valid_days)){
if(!(valid_days[i] %in% invalid_days)){
new_valid_days <- c(new_valid_days, valid_days[i])
}
}
#building our mapping as before...
day_end <- c(0)
counter <- 1
for(i in 1:nrow(data)){
if(substr(data[i, 1], 1, 10) != new_valid_days[counter]){
day_end <- c(day_end, i-1)
counter <- counter + 1
}
}
day_end <- c(day_end, nrow(data))
#Now we just calculate whatever summary statistics we want
all_sit <- c()
all_stand <- c()
all_move <- c()
for(i in 1:length(new_valid_days)){
sit <- c()
stand <- c()
move <- c()
for(j in (day_end[i]+1):day_end[i+1]){
if(data[j, 4] == 0){
sit <- c(sit, data[j, 3])
}else if(data[j, 4] ==1){
stand <- c(stand, data[j, 3])
}else{
move <- c(move, data[j, 3])
}
}
all_sit <- c(all_sit, sit)
all_stand <- c(all_stand, stand)
all_move <- c(all_move, move)
print(paste("SUMMARY STATISTICS FOR: ", new_valid_days[i]))
print(paste("    TOTAL NUMBER OF SITTING/LYING BOUTS: ", toString(length(sit))))
print(paste("    LARGEST SITTING/LYING BOUT: ", toString(max(unlist(sit)))))
print(paste("    SMALLEST SITTING/LYING BOUT: ", toString(min(unlist(sit)))))
print(paste("    AVERAGE SITTING/LYING BOUT: ", toString(mean(sit))))
print("")
print(paste("    TOTAL NUMBER OF STANDING BOUTS: ", toString(length(stand))))
print(paste("    LARGEST STANDING BOUT: ", toString(max(unlist(stand)))))
print(paste("    SMALLEST STANDING BOUT: ", toString(min(unlist(stand)))))
print(paste("    AVERAGE STANDING BOUT: ", toString(mean(stand))))
print("")
print(paste("    TOTAL NUMBER OF MOVING BOUTS: ", toString(length(move))))
print(paste("    LARGEST MOVING BOUT: ", toString(max(unlist(move)))))
print(paste("    SMALLEST MOVING BOUT: ", toString(min(unlist(move)))))
print(paste("    AVERAGE MOVING BOUT: ", toString(mean(move))))
print("")
print("")
}
for(i in 1){
print("SUMMARY STATISTICS FOR ENTIRE DATASET")
print(paste("    TOTAL NUMBER OF SITTING/LYING BOUTS: ", toString(length(all_sit))))
print(paste("    LARGEST SITTING/LYING BOUT: ", toString(max(unlist(all_sit)))))
print(paste("    SMALLEST SITTING/LYING BOUT: ", toString(min(unlist(all_sit)))))
print(paste("    AVERAGE SITTING/LYING BOUT: ", toString(mean(all_sit))))
print("")
print(paste("    TOTAL NUMBER OF STANDING BOUTS: ", toString(length(all_stand))))
print(paste("    LARGEST STANDING BOUT: ", toString(max(unlist(all_stand)))))
print(paste("    SMALLEST STANDING BOUT: ", toString(min(unlist(all_stand)))))
print(paste("    AVERAGE STANDING BOUT: ", toString(mean(stand))))
print("")
print(paste("    TOTAL NUMBER OF MOVING BOUTS: ", toString(length(all_move))))
print(paste("    LARGEST MOVING BOUT: ", toString(max(unlist(all_move)))))
print(paste("    SMALLEST MOVING BOUT: ", toString(min(unlist(all_move)))))
print(paste("    AVERAGE MOVING BOUT: ", toString(mean(all_move))))
print("")
print("")
}
write.csv(data, "valid_data.csv")
write.csv(invalid_data, "invalid_data.csv")
write.csv(sleep_data, "sleep_data.csv")
View(data)
View(data)
View(invalid_data)
View(invalid_data)
View(sleep_data)
View(sleep_data)
#set variable "wd" equal to a string containing the full path to the directory you intend to work from
wd <- "C:/Users/User/Desktop/PNC_Lab/activPAL-bout-detection"
setwd(wd)
#set variable "data_path" equal to a string containing the partial path FROM YOUR WORKING DIRECTORY
data_path <- "sample_data/SA009-SA009-AP840032 11Apr19 12-00am for 12d 16h 22m-VANE-PB08090417-Events.csv"
#now we're ready to go ahead and run our activPAL bout detection data reduction on our dataset
data <- activpalProcessing::activpal.file.reader(data_path)
View(data)
View(data)
View(sleep_data)
View(sleep_data)
#set variable "wd" equal to a string containing the full path to the directory you intend to work from
wd <- "C:/Users/User/Desktop/PNC_Lab/activPAL-bout-detection"
setwd(wd)
#set variable "data_path" equal to a string containing the partial path FROM YOUR WORKING DIRECTORY
data_path <- "sample_data/SA009-SA009-AP840032 11Apr19 12-00am for 12d 16h 22m-VANE-PB08090417-Events.csv"
#now we're ready to go ahead and run our activPAL bout detection data reduction on our dataset
data <- activpalProcessing::activpal.file.reader(data_path)
#first we count how many steps occur on each day
days <- 0
steps <- data.frame(days)
for(i in 1:nrow(data)){
date <- substr(data[i, 1], 1, 10)
if(!(date %in% colnames(steps))){
steps[, date] <- data[i, 5]
steps[1, "days"] <- steps[1, "days"] + 1
} else {
steps[1, date] <- data[i, 5]
}
}
steps$days <- NULL
#next we remove down to the 7 days with the largest step counts and save those days into a list"valid_days"
while(ncol(steps) > 7){
least_steps <- min(steps, na.rm = TRUE)
for(i in 1:ncol(data)){
if(least_steps == steps[1, i]){
steps[i] <- NULL
break
}
}
}
valid_days = colnames(steps)
print(valid_days)
print(steps)
#set variable "wd" equal to a string containing the full path to the directory you intend to work from
wd <- "C:/Users/User/Desktop/PNC_Lab/activPAL-bout-detection"
setwd(wd)
#set variable "data_path" equal to a string containing the partial path FROM YOUR WORKING DIRECTORY
data_path <- "sample_data/SA009-SA009-AP840032 11Apr19 12-00am for 12d 16h 22m-VANE-PB08090417-Events.csv"
#now we're ready to go ahead and run our activPAL bout detection data reduction on our dataset
data <- activpalProcessing::activpal.file.reader(data_path)
#first we count how many steps occur on each day
days <- 0
steps <- data.frame(days)
for(i in 1:nrow(data)){
date <- substr(data[i, 1], 1, 10)
if(!(date %in% colnames(steps))){
steps[, date] <- data[i, 5]
steps[1, "days"] <- steps[1, "days"] + 1
} else {
steps[1, date] <- data[i, 5]
}
}
steps$days <- NULL
print(steps)
#next we remove down to the 7 days with the largest step counts and save those days into a list"valid_days"
while(ncol(steps) > 7){
least_steps <- min(steps, na.rm = TRUE)
for(i in 1:ncol(data)){
if(least_steps == steps[1, i]){
steps[i] <- NULL
break
}
}
}
print(steps)
valid_days = colnames(steps)
print(valid_days)
